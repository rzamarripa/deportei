"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DocUtils = require("./doc-utils");

var Docxtemplater = function () {
	function Docxtemplater() {
		_classCallCheck(this, Docxtemplater);

		if (arguments.length > 0) {
			throw new Error("The constructor with parameters have been removed in docxtemplater 3.0, please check the upgrade guide.");
		}
		this.compiled = {};
		this.modules = [];
		this.setOptions({});
	}

	_createClass(Docxtemplater, [{
		key: "attachModule",
		value: function attachModule(module) {
			this.modules.push(module);
			return this;
		}
	}, {
		key: "setOptions",
		value: function setOptions(options) {
			var _this = this;

			this.options = options;
			Object.keys(DocUtils.defaults).forEach(function (key) {
				var defaultValue = DocUtils.defaults[key];
				_this[key] = _this.options[key] != null ? _this.options[key] : defaultValue;
			});
			if (this.fileType === "docx" || this.fileType === "pptx") {
				this.fileTypeConfig = Docxtemplater.FileTypeConfig[this.fileType];
			}
			this.fileTypeConfig = this.options.fileTypeConfig || this.fileTypeConfig;
			this.options.xmlFileNames = [];
			return this;
		}
	}, {
		key: "loadZip",
		value: function loadZip(zip) {
			if (zip.loadAsync) {
				throw new Error("Docxtemplater doesn't handle JSZip version >=3, see changelog");
			}
			this.zip = zip;
			return this;
		}
	}, {
		key: "renderFile",
		value: function renderFile(fileName) {
			var currentFile = this.createTemplateClass(fileName);
			this.zip.file(fileName, currentFile.render().content);
			this.compiled[fileName] = currentFile.postparsed;
		}
	}, {
		key: "compile",
		value: function compile() {
			this.templatedFiles = this.fileTypeConfig.getTemplatedFiles(this.zip);
		}
	}, {
		key: "render",
		value: function render() {
			var _this2 = this;

			this.modules = this.fileTypeConfig.baseModules.map(function (moduleFunction) {
				return moduleFunction();
			}).concat(this.modules);
			this.options = this.modules.reduce(function (options, module) {
				return module.optionsTransformer ? module.optionsTransformer(options, _this2) : options;
			}, this.options);
			this.xmlDocuments = this.options.xmlFileNames.reduce(function (xmlDocuments, fileName) {
				var content = _this2.zip.files[fileName].asText();
				xmlDocuments[fileName] = DocUtils.str2xml(content);
				return xmlDocuments;
			}, {});
			this.modules.forEach(function (module) {
				if (module.set) {
					module.set({ zip: _this2.zip, xmlDocuments: _this2.xmlDocuments });
				}
			});
			this.compile();
			// Loop inside all templatedFiles (ie xml files with content).
			// Sometimes they don't exist (footer.xml for example)
			this.templatedFiles.forEach(function (fileName) {
				if (_this2.zip.files[fileName] != null) {
					_this2.renderFile(fileName);
				}
			});
			Object.keys(this.xmlDocuments).forEach(function (fileName) {
				_this2.zip.remove(fileName);
				var content = DocUtils.encodeUtf8(DocUtils.xml2str(_this2.xmlDocuments[fileName]));
				return _this2.zip.file(fileName, content, {});
			});
			return this;
		}
	}, {
		key: "setData",
		value: function setData(tags) {
			this.tags = tags;
			return this;
		}
	}, {
		key: "getZip",
		value: function getZip() {
			return this.zip;
		}
	}, {
		key: "createTemplateClass",
		value: function createTemplateClass(path) {
			var usedData = this.zip.files[path].asText();
			return this.createTemplateClassFromContent(usedData, path);
		}
	}, {
		key: "createTemplateClassFromContent",
		value: function createTemplateClassFromContent(content, filePath) {
			var _this3 = this;

			var xmltOptions = {
				tags: this.tags,
				filePath: filePath
			};
			Object.keys(DocUtils.defaults).forEach(function (key) {
				xmltOptions[key] = _this3[key];
			});
			xmltOptions.fileTypeConfig = this.fileTypeConfig;
			xmltOptions.modules = this.modules;
			return new Docxtemplater.XmlTemplater(content, xmltOptions);
		}
	}, {
		key: "getFullText",
		value: function getFullText(path) {
			return this.createTemplateClass(path || this.fileTypeConfig.textPath).getFullText();
		}
	}, {
		key: "getTemplatedFiles",
		value: function getTemplatedFiles() {
			this.compile();
			return this.templatedFiles;
		}
	}]);

	return Docxtemplater;
}();

Docxtemplater.DocUtils = require("./doc-utils");
Docxtemplater.Errors = require("./errors");
Docxtemplater.XmlTemplater = require("./xml-templater");
Docxtemplater.FileTypeConfig = require("./file-type-config");
Docxtemplater.XmlMatcher = require("./xml-matcher");
module.exports = Docxtemplater;